{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"MASS 2: Microcalorimeter Analysis Software Suite Overview of Mass 2 MASS is a Python software suite designed to analyze pulse records from high-resolution, cryogenic microcalorimeters. We use MASS with pulse records from x-ray and gamma-ray spectrometers, performing a sequence of analysis, or \"calibration\" steps to extract a high-precision estimate of the energy from each record. With raw pulse records and MASS, you can: Analyze data from one or multiple detectors at one time. Analyze data from one or more raw pulse data files per detector. Analyze a fixed dataset taken in the past, or perform \"online\" analysis of a dataset still being acquired. Analyze data from time-division multiplexed (TDM) and microwave-multiplexed (\u00b5MUX) systems. Choose and apply data cuts. Compute and apply \"optimal filters\" of various types. Fix complex line shapes in an energy spectrum. Estimate and apply accurate functions for absolute-energy calibration. Win friends and influence people. Major concepts Mass2 is built on a few core technologies: Pola.rs , a high-performance modern dataframe library. Organizes the data structures. Numpy . For numerical arrays and scientific computation. Scipy . Additional algorithms for scientific computation. Unlike Mass version 1, Mass 2 leverages existing libraries for data organization. This offers the advantage that documentation, bug fixes, and testing are provided by the larger open-source software community.","title":"Home"},{"location":"#mass-2-microcalorimeter-analysis-software-suite","text":"","title":"MASS 2: Microcalorimeter Analysis Software Suite"},{"location":"#overview-of-mass-2","text":"MASS is a Python software suite designed to analyze pulse records from high-resolution, cryogenic microcalorimeters. We use MASS with pulse records from x-ray and gamma-ray spectrometers, performing a sequence of analysis, or \"calibration\" steps to extract a high-precision estimate of the energy from each record. With raw pulse records and MASS, you can: Analyze data from one or multiple detectors at one time. Analyze data from one or more raw pulse data files per detector. Analyze a fixed dataset taken in the past, or perform \"online\" analysis of a dataset still being acquired. Analyze data from time-division multiplexed (TDM) and microwave-multiplexed (\u00b5MUX) systems. Choose and apply data cuts. Compute and apply \"optimal filters\" of various types. Fix complex line shapes in an energy spectrum. Estimate and apply accurate functions for absolute-energy calibration. Win friends and influence people.","title":"Overview of Mass 2"},{"location":"#major-concepts","text":"Mass2 is built on a few core technologies: Pola.rs , a high-performance modern dataframe library. Organizes the data structures. Numpy . For numerical arrays and scientific computation. Scipy . Additional algorithms for scientific computation. Unlike Mass version 1, Mass 2 leverages existing libraries for data organization. This offers the advantage that documentation, bug fixes, and testing are provided by the larger open-source software community.","title":"Major concepts"},{"location":"LJHfiles/","text":"LJH Memorial File Format LJH Version 2.2.0 is the current LJH file format (since 2015). An LJH file contains segmented, time-series data that represent separate triggered pulses observed in a single cryogenic microcalorimeter. The LJH file format consists of a human-readable ASCII header followed by an arbitrary number of binary data records . Information in the header specifies the exact length in bytes of each data record. Header Information The human-readable ASCII header is the start of the LJH file. That means you can say less myfile_chan5.ljh at a unix terminal and get meaningful information about the file before the gibberish starts. Handy, right? The header is somewhat fragile (it might have been better written in YAML or TOML or even JSON, but we decided just to live with it). It consists of key-value pairs, with a format of Key: value , one pair per line. Header Notes: Lines begining with # are usually ignored. #End of Header marks the end of the header and the transition to the binary data. #End of Description has special meaning if System description of this File: has been read. Newlines are the newlines of the digitizing computer. The interpreting program must accept LF, CR, or CRLF. Capitalization must be matched. One space follows a colon. Any additional spaces are treated as part of the value. Programs that read LJH files ignore header keys that are unexpected or unneeded. #LJH Memorial File Format This line indicates that the file is based on format described here. Save File Format Version: 2.2.0 Software Version: DASTARD version 0.2.15 Software Git Hash: 85ab821 Data source: Abaco These lines uniquely identify the exact format, so the interpreting program can adapt. While the first line should be sufficient for this purpose, the second and third lines take in the possibility that a particular program may have a bug. The interpreting program may be aware of this bug and compensate. The Data source is meant for later human reference. Number of rows: 74 Number of columns: 1 Row number (from 0-73 inclusive): 12 Column number (from 0-0 inclusive): 0 Number of channels: 74 Channel name: chan12 Channel: 12 ChannelIndex (in dastard): 12 Dastard inserts this information to help downstream analysis tools understand the array being used when this file was acquired. Digitized Word Size in Bytes: 2 Each sample is stored in this many bytes. Location: LLNL Cryostat: C3PO Thermometer: GRT1 Temperature (Ohm or K): 0.1 Bridge range: 20.0E3 Magnetic field (A or Gauss): 0.75 Detector: SnTES#8 Sample: Orange peel Excitation/Source: none Operator: Leisure Larry Like the several lines above, most lines are comments for later human use and are not interpreted by general-purpose LJH readers. System description of this File: blah blah blah User description of this File: blah blah blah #End of Description This is a multiline comment. Once the Description of this File: line is read, all following lines are concantenated until #End of Description is read. Again, this is ignored by programs that read LJH files. Number of Digitizers: 1 Number of Active Channels: 2 The number of digitizers and channels present in the file are given so that space may be allocated for them by the interpreting program, if necessary. Timestamp offset (s): 3016738980.049000 The meaning of this and the means of interpreting it are dependent upon the particular programs creating and reading this file. It was a necessary offset in earlier versions of LJH, where we did not reserve enough bytes per record to record a full timestamp. In LJH 2.2, it serves as a simple zero-time (all records should be no earlier than this \"offset\"). Server Start Time: 18 Nov 2022, 15:47:34 MST First Record Time: 18 Nov 2022, 16:54:15 MST These times show when the server (Dastard, in this case) started running, and when the first record was written to this file. Timebase: 5.000000E-8 Number of samples per point: 1 Timebase gives the sampling period (in seconds). Number of samples per point is generally 1, but can be more in special cases where samples are averaged and downsampled before recording. Presamples: 256 Total Samples: 1024 Total samples is the actual record length in samples. The trigger point will be located at sample number Presamples. Binary Information If you read an LJH file until the characters #End of Header plus the following CR and/or LF, then the remainder of the file is the binary section. It consists of a sequence of data records. Each record starts with a 16-byte time marker. The record's waveform data consists of the next L*M bytes, where L is the number of samples ( Total Samples: value from the header) and M is the number of bytes per sample ( Digitized Word Size in Bytes: from the header). M is always 2 bytes per sample, in practice. The full record's length is 16+L*M . All values in the data record are little endian. The first 8-byte word is the subframe counter. It counts the number of subframe times read out since the server started. If the server has to resynchronize on the raw data, then the subframe counter will be incremented by an estimate to account for the time missed. For TDM data, the subframe rate is equal to the row rate, also known as the line rate . For \u00b5MUX data, subframes run at a multiple of the frame rate given by the Subframe divisions: value in the LJH header (typically 64). The second 8-byte word is the POSIX microsecond time, i.e., the time in microseconds since 1 January 1970 00:00 UT. (Warning: this will overflow in only 292,226 years if you interpret it as a signed number.) The next L words (of M bytes each) are the data record, as a signed or unsigned integer. (Typically, we use signed for the TDM error signal and unsigned for TDM feedback or for \u00b5MUX data.) Earlier versions of the LJH standard Binary Information (for LJH version 2.1.0) Version 2.1.0 follows. This version was made obsolete in 2015 by version 2.2.0. Each record starts with a 6-byte time marker. The record's waveform data consists of the next L*M bytes, where L is the number of samples ( Total Samples: value from the header) and M is the number of bytes per sample ( Digitized Word Size in Bytes: from the header). M is always 2 bytes per sample, in practice. The full record's length is 6+L*M . All values in the data record are little endian. The first byte is a \"4 microsecond tick\". That is, it counts microseconds past the millisecond counter and records the count divided by 4. Beware that previous versions of LJH used the first byte to signify something about the type of data. Igor seems to ignore this byte, though, so I think we're okay to stuff timing information into it. The second byte used to signify a channel number N, which corresponds to the Nth channel described in the header. Channel number 255 is reserved for temperature readout with the DMM. Since 2010, this has always been meaningless. The next 4 bytes are an unsigned 32-bit number that is the value of a millisecond counter on the digitizing computer. The next L words (of M bytes each) are the data record, as a signed or unsigned integer. (Typically, we use signed for the TDM error signal and unsigned for the TDM feedback.) Changelog Version 2.2.0 (6 Aug 2015) Changed the binary definition to include 8 bytes each record for pulse timing (microsecond precision) and frame number. Version 2.1.0 (23 Sep 2011) Used the first byte of each record to get 4 microsec timing resolution instead of 1 ms. Version 2.0.0 (27 Mar 2011) Defined inversion and offset more clearly Version 2.0.0 (5 Jan 2001) Changed definition of discrimination level Version 2.0.0 (24 May 2000) since most PCs have least significant byte first, the binary information has been changed to default Version 1.1.0 (8 May 2000) added a few more user and channel parameters as well as provisions for temperature monitoring Initial 1.0.0 (5 Aug 1999) definition by Larry J. Hiller","title":"LJH file format"},{"location":"LJHfiles/#ljh-memorial-file-format","text":"LJH Version 2.2.0 is the current LJH file format (since 2015). An LJH file contains segmented, time-series data that represent separate triggered pulses observed in a single cryogenic microcalorimeter. The LJH file format consists of a human-readable ASCII header followed by an arbitrary number of binary data records . Information in the header specifies the exact length in bytes of each data record.","title":"LJH Memorial File Format"},{"location":"LJHfiles/#header-information","text":"The human-readable ASCII header is the start of the LJH file. That means you can say less myfile_chan5.ljh at a unix terminal and get meaningful information about the file before the gibberish starts. Handy, right? The header is somewhat fragile (it might have been better written in YAML or TOML or even JSON, but we decided just to live with it). It consists of key-value pairs, with a format of Key: value , one pair per line.","title":"Header Information"},{"location":"LJHfiles/#header-notes","text":"Lines begining with # are usually ignored. #End of Header marks the end of the header and the transition to the binary data. #End of Description has special meaning if System description of this File: has been read. Newlines are the newlines of the digitizing computer. The interpreting program must accept LF, CR, or CRLF. Capitalization must be matched. One space follows a colon. Any additional spaces are treated as part of the value. Programs that read LJH files ignore header keys that are unexpected or unneeded. #LJH Memorial File Format This line indicates that the file is based on format described here. Save File Format Version: 2.2.0 Software Version: DASTARD version 0.2.15 Software Git Hash: 85ab821 Data source: Abaco These lines uniquely identify the exact format, so the interpreting program can adapt. While the first line should be sufficient for this purpose, the second and third lines take in the possibility that a particular program may have a bug. The interpreting program may be aware of this bug and compensate. The Data source is meant for later human reference. Number of rows: 74 Number of columns: 1 Row number (from 0-73 inclusive): 12 Column number (from 0-0 inclusive): 0 Number of channels: 74 Channel name: chan12 Channel: 12 ChannelIndex (in dastard): 12 Dastard inserts this information to help downstream analysis tools understand the array being used when this file was acquired. Digitized Word Size in Bytes: 2 Each sample is stored in this many bytes. Location: LLNL Cryostat: C3PO Thermometer: GRT1 Temperature (Ohm or K): 0.1 Bridge range: 20.0E3 Magnetic field (A or Gauss): 0.75 Detector: SnTES#8 Sample: Orange peel Excitation/Source: none Operator: Leisure Larry Like the several lines above, most lines are comments for later human use and are not interpreted by general-purpose LJH readers. System description of this File: blah blah blah User description of this File: blah blah blah #End of Description This is a multiline comment. Once the Description of this File: line is read, all following lines are concantenated until #End of Description is read. Again, this is ignored by programs that read LJH files. Number of Digitizers: 1 Number of Active Channels: 2 The number of digitizers and channels present in the file are given so that space may be allocated for them by the interpreting program, if necessary. Timestamp offset (s): 3016738980.049000 The meaning of this and the means of interpreting it are dependent upon the particular programs creating and reading this file. It was a necessary offset in earlier versions of LJH, where we did not reserve enough bytes per record to record a full timestamp. In LJH 2.2, it serves as a simple zero-time (all records should be no earlier than this \"offset\"). Server Start Time: 18 Nov 2022, 15:47:34 MST First Record Time: 18 Nov 2022, 16:54:15 MST These times show when the server (Dastard, in this case) started running, and when the first record was written to this file. Timebase: 5.000000E-8 Number of samples per point: 1 Timebase gives the sampling period (in seconds). Number of samples per point is generally 1, but can be more in special cases where samples are averaged and downsampled before recording. Presamples: 256 Total Samples: 1024 Total samples is the actual record length in samples. The trigger point will be located at sample number Presamples.","title":"Header Notes:"},{"location":"LJHfiles/#binary-information","text":"If you read an LJH file until the characters #End of Header plus the following CR and/or LF, then the remainder of the file is the binary section. It consists of a sequence of data records. Each record starts with a 16-byte time marker. The record's waveform data consists of the next L*M bytes, where L is the number of samples ( Total Samples: value from the header) and M is the number of bytes per sample ( Digitized Word Size in Bytes: from the header). M is always 2 bytes per sample, in practice. The full record's length is 16+L*M . All values in the data record are little endian. The first 8-byte word is the subframe counter. It counts the number of subframe times read out since the server started. If the server has to resynchronize on the raw data, then the subframe counter will be incremented by an estimate to account for the time missed. For TDM data, the subframe rate is equal to the row rate, also known as the line rate . For \u00b5MUX data, subframes run at a multiple of the frame rate given by the Subframe divisions: value in the LJH header (typically 64). The second 8-byte word is the POSIX microsecond time, i.e., the time in microseconds since 1 January 1970 00:00 UT. (Warning: this will overflow in only 292,226 years if you interpret it as a signed number.) The next L words (of M bytes each) are the data record, as a signed or unsigned integer. (Typically, we use signed for the TDM error signal and unsigned for TDM feedback or for \u00b5MUX data.)","title":"Binary Information"},{"location":"LJHfiles/#earlier-versions-of-the-ljh-standard","text":"","title":"Earlier versions of the LJH standard"},{"location":"LJHfiles/#binary-information-for-ljh-version-210","text":"Version 2.1.0 follows. This version was made obsolete in 2015 by version 2.2.0. Each record starts with a 6-byte time marker. The record's waveform data consists of the next L*M bytes, where L is the number of samples ( Total Samples: value from the header) and M is the number of bytes per sample ( Digitized Word Size in Bytes: from the header). M is always 2 bytes per sample, in practice. The full record's length is 6+L*M . All values in the data record are little endian. The first byte is a \"4 microsecond tick\". That is, it counts microseconds past the millisecond counter and records the count divided by 4. Beware that previous versions of LJH used the first byte to signify something about the type of data. Igor seems to ignore this byte, though, so I think we're okay to stuff timing information into it. The second byte used to signify a channel number N, which corresponds to the Nth channel described in the header. Channel number 255 is reserved for temperature readout with the DMM. Since 2010, this has always been meaningless. The next 4 bytes are an unsigned 32-bit number that is the value of a millisecond counter on the digitizing computer. The next L words (of M bytes each) are the data record, as a signed or unsigned integer. (Typically, we use signed for the TDM error signal and unsigned for the TDM feedback.)","title":"Binary Information (for LJH version 2.1.0)"},{"location":"LJHfiles/#changelog","text":"Version 2.2.0 (6 Aug 2015) Changed the binary definition to include 8 bytes each record for pulse timing (microsecond precision) and frame number. Version 2.1.0 (23 Sep 2011) Used the first byte of each record to get 4 microsec timing resolution instead of 1 ms. Version 2.0.0 (27 Mar 2011) Defined inversion and offset more clearly Version 2.0.0 (5 Jan 2001) Changed definition of discrimination level Version 2.0.0 (24 May 2000) since most PCs have least significant byte first, the binary information has been changed to default Version 1.1.0 (8 May 2000) added a few more user and channel parameters as well as provisions for temperature monitoring Initial 1.0.0 (5 Aug 1999) definition by Larry J. Hiller","title":"Changelog"},{"location":"about/","text":"Authors MASS is the work of physicists from Quantum Sensors Division of the NIST Boulder Labs and the University of Colorado Physics Department , with substantial contributions from: Joe Fowler , project director Galen O'Neil , co-director Dan Becker Young-Il Joe Jamie Titus Joshua Ho Many collaborators, who have made many bug reports, bug fixes, and feature requests. Major Versions MASS version 2 was begin in August 2025. It is still unstable, in alpha or pre-alpha status. Find it at https://github.com/usnistgov/mass2 MASS version 1 was begun in November 2010. Bug-fix development continues. Find it at https://github.com/usnistgov/mass","title":"About"},{"location":"about/#authors","text":"MASS is the work of physicists from Quantum Sensors Division of the NIST Boulder Labs and the University of Colorado Physics Department , with substantial contributions from: Joe Fowler , project director Galen O'Neil , co-director Dan Becker Young-Il Joe Jamie Titus Joshua Ho Many collaborators, who have made many bug reports, bug fixes, and feature requests.","title":"Authors"},{"location":"about/#major-versions","text":"MASS version 2 was begin in August 2025. It is still unstable, in alpha or pre-alpha status. Find it at https://github.com/usnistgov/mass2 MASS version 1 was begun in November 2010. Bug-fix development continues. Find it at https://github.com/usnistgov/mass","title":"Major Versions"}]}